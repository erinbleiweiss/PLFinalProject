Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    QUOTE
    TRUE
    NIL
    SQUOTE
    FALSE

Grammar

Rule 0     S' -> program
Rule 1     program -> expressions
Rule 2     program -> declaration
Rule 3     program -> print
Rule 4     program -> empty
Rule 5     expressions -> expression
Rule 6     expressions -> expressions expression
Rule 7     expression -> operation
Rule 8     operation -> addition
Rule 9     operation -> subtraction
Rule 10    operation -> multiplication
Rule 11    operation -> division
Rule 12    addition -> INTEGER PLUS INTEGER
Rule 13    addition -> INTEGER PLUS addition
Rule 14    subtraction -> INTEGER MINUS INTEGER
Rule 15    subtraction -> INTEGER MINUS subtraction
Rule 16    multiplication -> INTEGER MULT INTEGER
Rule 17    multiplication -> INTEGER MULT multiplication
Rule 18    division -> INTEGER DIV INTEGER
Rule 19    division -> INTEGER DIV division
Rule 20    declaration -> let
Rule 21    let -> LET TEXT EQUALS INTEGER
Rule 22    let -> LET TEXT EQUALS string
Rule 23    string -> CLSTRING
Rule 24    print -> PRINT LPAREN TEXT RPAREN
Rule 25    print -> PRINT LPAREN string RPAREN
Rule 26    print -> PRINT LPAREN expression RPAREN
Rule 27    empty -> <empty>

Terminals, with rules where they appear

CLSTRING             : 23
DIV                  : 18 19
EQUALS               : 21 22
FALSE                : 
INTEGER              : 12 12 13 14 14 15 16 16 17 18 18 19 21
LET                  : 21 22
LPAREN               : 24 25 26
MINUS                : 14 15
MULT                 : 16 17
NIL                  : 
PLUS                 : 12 13
PRINT                : 24 25 26
QUOTE                : 
RPAREN               : 24 25 26
SQUOTE               : 
TEXT                 : 21 22 24
TRUE                 : 
error                : 

Nonterminals, with rules where they appear

addition             : 8 13
declaration          : 2
division             : 11 19
empty                : 4
expression           : 5 6 26
expressions          : 1 6
let                  : 20
multiplication       : 10 17
operation            : 7
print                : 3
program              : 0
string               : 22 25
subtraction          : 9 15

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . expressions
    (2) program -> . declaration
    (3) program -> . print
    (4) program -> . empty
    (5) expressions -> . expression
    (6) expressions -> . expressions expression
    (20) declaration -> . let
    (24) print -> . PRINT LPAREN TEXT RPAREN
    (25) print -> . PRINT LPAREN string RPAREN
    (26) print -> . PRINT LPAREN expression RPAREN
    (27) empty -> .
    (7) expression -> . operation
    (21) let -> . LET TEXT EQUALS INTEGER
    (22) let -> . LET TEXT EQUALS string
    (8) operation -> . addition
    (9) operation -> . subtraction
    (10) operation -> . multiplication
    (11) operation -> . division
    (12) addition -> . INTEGER PLUS INTEGER
    (13) addition -> . INTEGER PLUS addition
    (14) subtraction -> . INTEGER MINUS INTEGER
    (15) subtraction -> . INTEGER MINUS subtraction
    (16) multiplication -> . INTEGER MULT INTEGER
    (17) multiplication -> . INTEGER MULT multiplication
    (18) division -> . INTEGER DIV INTEGER
    (19) division -> . INTEGER DIV division

    PRINT           shift and go to state 1
    $end            reduce using rule 27 (empty -> .)
    LET             shift and go to state 14
    INTEGER         shift and go to state 9

    expression                     shift and go to state 10
    subtraction                    shift and go to state 2
    program                        shift and go to state 3
    expressions                    shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 4
    division                       shift and go to state 5
    print                          shift and go to state 13
    let                            shift and go to state 6
    multiplication                 shift and go to state 7
    operation                      shift and go to state 15
    addition                       shift and go to state 8

state 1

    (24) print -> PRINT . LPAREN TEXT RPAREN
    (25) print -> PRINT . LPAREN string RPAREN
    (26) print -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 16


state 2

    (9) operation -> subtraction .

    INTEGER         reduce using rule 9 (operation -> subtraction .)
    $end            reduce using rule 9 (operation -> subtraction .)
    RPAREN          reduce using rule 9 (operation -> subtraction .)


state 3

    (0) S' -> program .



state 4

    (4) program -> empty .

    $end            reduce using rule 4 (program -> empty .)


state 5

    (11) operation -> division .

    INTEGER         reduce using rule 11 (operation -> division .)
    $end            reduce using rule 11 (operation -> division .)
    RPAREN          reduce using rule 11 (operation -> division .)


state 6

    (20) declaration -> let .

    $end            reduce using rule 20 (declaration -> let .)


state 7

    (10) operation -> multiplication .

    INTEGER         reduce using rule 10 (operation -> multiplication .)
    $end            reduce using rule 10 (operation -> multiplication .)
    RPAREN          reduce using rule 10 (operation -> multiplication .)


state 8

    (8) operation -> addition .

    INTEGER         reduce using rule 8 (operation -> addition .)
    $end            reduce using rule 8 (operation -> addition .)
    RPAREN          reduce using rule 8 (operation -> addition .)


state 9

    (12) addition -> INTEGER . PLUS INTEGER
    (13) addition -> INTEGER . PLUS addition
    (14) subtraction -> INTEGER . MINUS INTEGER
    (15) subtraction -> INTEGER . MINUS subtraction
    (16) multiplication -> INTEGER . MULT INTEGER
    (17) multiplication -> INTEGER . MULT multiplication
    (18) division -> INTEGER . DIV INTEGER
    (19) division -> INTEGER . DIV division

    PLUS            shift and go to state 20
    MINUS           shift and go to state 17
    MULT            shift and go to state 19
    DIV             shift and go to state 18


state 10

    (5) expressions -> expression .

    INTEGER         reduce using rule 5 (expressions -> expression .)
    $end            reduce using rule 5 (expressions -> expression .)


state 11

    (1) program -> expressions .
    (6) expressions -> expressions . expression
    (7) expression -> . operation
    (8) operation -> . addition
    (9) operation -> . subtraction
    (10) operation -> . multiplication
    (11) operation -> . division
    (12) addition -> . INTEGER PLUS INTEGER
    (13) addition -> . INTEGER PLUS addition
    (14) subtraction -> . INTEGER MINUS INTEGER
    (15) subtraction -> . INTEGER MINUS subtraction
    (16) multiplication -> . INTEGER MULT INTEGER
    (17) multiplication -> . INTEGER MULT multiplication
    (18) division -> . INTEGER DIV INTEGER
    (19) division -> . INTEGER DIV division

    $end            reduce using rule 1 (program -> expressions .)
    INTEGER         shift and go to state 9

    expression                     shift and go to state 21
    subtraction                    shift and go to state 2
    division                       shift and go to state 5
    multiplication                 shift and go to state 7
    operation                      shift and go to state 15
    addition                       shift and go to state 8

state 12

    (2) program -> declaration .

    $end            reduce using rule 2 (program -> declaration .)


state 13

    (3) program -> print .

    $end            reduce using rule 3 (program -> print .)


state 14

    (21) let -> LET . TEXT EQUALS INTEGER
    (22) let -> LET . TEXT EQUALS string

    TEXT            shift and go to state 22


state 15

    (7) expression -> operation .

    INTEGER         reduce using rule 7 (expression -> operation .)
    $end            reduce using rule 7 (expression -> operation .)
    RPAREN          reduce using rule 7 (expression -> operation .)


state 16

    (24) print -> PRINT LPAREN . TEXT RPAREN
    (25) print -> PRINT LPAREN . string RPAREN
    (26) print -> PRINT LPAREN . expression RPAREN
    (23) string -> . CLSTRING
    (7) expression -> . operation
    (8) operation -> . addition
    (9) operation -> . subtraction
    (10) operation -> . multiplication
    (11) operation -> . division
    (12) addition -> . INTEGER PLUS INTEGER
    (13) addition -> . INTEGER PLUS addition
    (14) subtraction -> . INTEGER MINUS INTEGER
    (15) subtraction -> . INTEGER MINUS subtraction
    (16) multiplication -> . INTEGER MULT INTEGER
    (17) multiplication -> . INTEGER MULT multiplication
    (18) division -> . INTEGER DIV INTEGER
    (19) division -> . INTEGER DIV division

    TEXT            shift and go to state 25
    CLSTRING        shift and go to state 26
    INTEGER         shift and go to state 9

    expression                     shift and go to state 23
    string                         shift and go to state 24
    subtraction                    shift and go to state 2
    division                       shift and go to state 5
    multiplication                 shift and go to state 7
    operation                      shift and go to state 15
    addition                       shift and go to state 8

state 17

    (14) subtraction -> INTEGER MINUS . INTEGER
    (15) subtraction -> INTEGER MINUS . subtraction
    (14) subtraction -> . INTEGER MINUS INTEGER
    (15) subtraction -> . INTEGER MINUS subtraction

    INTEGER         shift and go to state 28

    subtraction                    shift and go to state 27

state 18

    (18) division -> INTEGER DIV . INTEGER
    (19) division -> INTEGER DIV . division
    (18) division -> . INTEGER DIV INTEGER
    (19) division -> . INTEGER DIV division

    INTEGER         shift and go to state 30

    division                       shift and go to state 29

state 19

    (16) multiplication -> INTEGER MULT . INTEGER
    (17) multiplication -> INTEGER MULT . multiplication
    (16) multiplication -> . INTEGER MULT INTEGER
    (17) multiplication -> . INTEGER MULT multiplication

    INTEGER         shift and go to state 32

    multiplication                 shift and go to state 31

state 20

    (12) addition -> INTEGER PLUS . INTEGER
    (13) addition -> INTEGER PLUS . addition
    (12) addition -> . INTEGER PLUS INTEGER
    (13) addition -> . INTEGER PLUS addition

    INTEGER         shift and go to state 33

    addition                       shift and go to state 34

state 21

    (6) expressions -> expressions expression .

    INTEGER         reduce using rule 6 (expressions -> expressions expression .)
    $end            reduce using rule 6 (expressions -> expressions expression .)


state 22

    (21) let -> LET TEXT . EQUALS INTEGER
    (22) let -> LET TEXT . EQUALS string

    EQUALS          shift and go to state 35


state 23

    (26) print -> PRINT LPAREN expression . RPAREN

    RPAREN          shift and go to state 36


state 24

    (25) print -> PRINT LPAREN string . RPAREN

    RPAREN          shift and go to state 37


state 25

    (24) print -> PRINT LPAREN TEXT . RPAREN

    RPAREN          shift and go to state 38


state 26

    (23) string -> CLSTRING .

    RPAREN          reduce using rule 23 (string -> CLSTRING .)
    $end            reduce using rule 23 (string -> CLSTRING .)


state 27

    (15) subtraction -> INTEGER MINUS subtraction .

    INTEGER         reduce using rule 15 (subtraction -> INTEGER MINUS subtraction .)
    $end            reduce using rule 15 (subtraction -> INTEGER MINUS subtraction .)
    RPAREN          reduce using rule 15 (subtraction -> INTEGER MINUS subtraction .)


state 28

    (14) subtraction -> INTEGER MINUS INTEGER .
    (14) subtraction -> INTEGER . MINUS INTEGER
    (15) subtraction -> INTEGER . MINUS subtraction

    INTEGER         reduce using rule 14 (subtraction -> INTEGER MINUS INTEGER .)
    $end            reduce using rule 14 (subtraction -> INTEGER MINUS INTEGER .)
    RPAREN          reduce using rule 14 (subtraction -> INTEGER MINUS INTEGER .)
    MINUS           shift and go to state 17


state 29

    (19) division -> INTEGER DIV division .

    INTEGER         reduce using rule 19 (division -> INTEGER DIV division .)
    $end            reduce using rule 19 (division -> INTEGER DIV division .)
    RPAREN          reduce using rule 19 (division -> INTEGER DIV division .)


state 30

    (18) division -> INTEGER DIV INTEGER .
    (18) division -> INTEGER . DIV INTEGER
    (19) division -> INTEGER . DIV division

    INTEGER         reduce using rule 18 (division -> INTEGER DIV INTEGER .)
    $end            reduce using rule 18 (division -> INTEGER DIV INTEGER .)
    RPAREN          reduce using rule 18 (division -> INTEGER DIV INTEGER .)
    DIV             shift and go to state 18


state 31

    (17) multiplication -> INTEGER MULT multiplication .

    INTEGER         reduce using rule 17 (multiplication -> INTEGER MULT multiplication .)
    $end            reduce using rule 17 (multiplication -> INTEGER MULT multiplication .)
    RPAREN          reduce using rule 17 (multiplication -> INTEGER MULT multiplication .)


state 32

    (16) multiplication -> INTEGER MULT INTEGER .
    (16) multiplication -> INTEGER . MULT INTEGER
    (17) multiplication -> INTEGER . MULT multiplication

    INTEGER         reduce using rule 16 (multiplication -> INTEGER MULT INTEGER .)
    $end            reduce using rule 16 (multiplication -> INTEGER MULT INTEGER .)
    RPAREN          reduce using rule 16 (multiplication -> INTEGER MULT INTEGER .)
    MULT            shift and go to state 19


state 33

    (12) addition -> INTEGER PLUS INTEGER .
    (12) addition -> INTEGER . PLUS INTEGER
    (13) addition -> INTEGER . PLUS addition

    INTEGER         reduce using rule 12 (addition -> INTEGER PLUS INTEGER .)
    $end            reduce using rule 12 (addition -> INTEGER PLUS INTEGER .)
    RPAREN          reduce using rule 12 (addition -> INTEGER PLUS INTEGER .)
    PLUS            shift and go to state 20


state 34

    (13) addition -> INTEGER PLUS addition .

    INTEGER         reduce using rule 13 (addition -> INTEGER PLUS addition .)
    $end            reduce using rule 13 (addition -> INTEGER PLUS addition .)
    RPAREN          reduce using rule 13 (addition -> INTEGER PLUS addition .)


state 35

    (21) let -> LET TEXT EQUALS . INTEGER
    (22) let -> LET TEXT EQUALS . string
    (23) string -> . CLSTRING

    INTEGER         shift and go to state 40
    CLSTRING        shift and go to state 26

    string                         shift and go to state 39

state 36

    (26) print -> PRINT LPAREN expression RPAREN .

    $end            reduce using rule 26 (print -> PRINT LPAREN expression RPAREN .)


state 37

    (25) print -> PRINT LPAREN string RPAREN .

    $end            reduce using rule 25 (print -> PRINT LPAREN string RPAREN .)


state 38

    (24) print -> PRINT LPAREN TEXT RPAREN .

    $end            reduce using rule 24 (print -> PRINT LPAREN TEXT RPAREN .)


state 39

    (22) let -> LET TEXT EQUALS string .

    $end            reduce using rule 22 (let -> LET TEXT EQUALS string .)


state 40

    (21) let -> LET TEXT EQUALS INTEGER .

    $end            reduce using rule 21 (let -> LET TEXT EQUALS INTEGER .)

